[
["index.html", "Auto Formation R avancé Chapitre 1 Introduction 1.1 Objectif 1.2 Ressources principales 1.3 Les participants", " Auto Formation R avancé Le groupe State Of The R in Roscoff 2017-09-01 Chapitre 1 Introduction 1.1 Objectif Le groupe State Of The R (SOTR) s’est réuni à Roscoff du 28 août 2017 au 1\\(^{\\mbox{er}}\\) septembre 2017 pour une semaine d’auto-formation autour du logiciel R. Différents sujets ont été abordés durant cette semaine Utilisation de git (surtout GitHub, Chaptire 2 ) Automatisation et reproductibilité du code : rmarkdown ( Chapitres 3, 4, 5), Manipulation de données :tidy (Chapitre 6) Programmation orientée objets : R6 class (Chapitre 7), Aspects techniques : Production de packages, Rcpp (Chapitre 8). Nous avons travaillé avec R (3.4.1) et Rstudio (1.1.350) sur les plateformes linux (ubuntu version &gt; 15.04), macosx (Sierra 10.12.6), windows (7). Ce livre résume les expériences des participants durant l’atelier. 1.2 Ressources principales http://rmarkdown.rstudio.com/ https://bookdown.org/yihui/blogdown/ https://bookdown.org/yihui/bookdown/ https://rstudio.github.io/learnr/ http://r4ds.had.co.nz/ http://adv-r.had.co.nz/ 1.3 Les participants Christophe Ambroise Julie Aubert \\(\\pi R\\) Barbillon Séverine Bord Mathieu Carmassi Julien Chiquet Jessica Cosmao-Tressou Sophie Donnet Marie-Pierre Etienne Marie Perrot-Dockes Timothée Tabouy "],
["github.html", "Chapitre 2 Git via GitHub 2.1 Charger un dossier d’un collaborateur depuis “GitHub.com” vers son espace local “GitHub Desktop” pour modification 2.2 Renvoyer les fichiers modifiés de son espace “GitHub Desktop” vers le repository d’origine sur “GitHub.com” 2.3 Références", " Chapitre 2 Git via GitHub 2.1 Charger un dossier d’un collaborateur depuis “GitHub.com” vers son espace local “GitHub Desktop” pour modification Dans “Github.com”, aller sur le dossier à copier sur son espace local, cliquer sur “clone or download” ; cela ouvre une fenêtre avec l’adresse HTTPS ou SSH ; 3 solutions sont possibles : copier l’adresse HTTPS https://github.com/username/my_repository.git ou SSH git@github.com:username/my_repository.git. Dans GitHub Desktop aller sur file -&gt; clone repository -&gt; coller l’adresse HTTPS ou SSH Cliquer sur Open in Desktop (indiquer l’éxécutable GitHub.exe à la 1ère utilisation) en ligne de commande depuis le Git Shell de GitHub Desktop, se placer dans le répertoire souhaité $ cd path et taper la commande $ git clone https://github.com/username/my_repository.git ou $ git clone git@github.com:username/my_repository.git modifier le fichier en l’ouvrant comme classiquement et enregistrer ; la modification est prise en compte automatiquement dans le GitHub desktop 2.2 Renvoyer les fichiers modifiés de son espace “GitHub Desktop” vers le repository d’origine sur “GitHub.com” 2.2.1 Cas où les modifications ne sont pas en conflit avec la version courante Dans GitHub Desktop, mettre un commentaire court sur la modification dans cadre summary, commentaire plus long dans description éventuellement, cliquer sur Commit to master pour valider localement les modifications cliquer ensuite sur Push Origin pour renvoyer vers le répertoire source situé dans “GitHub.com” Dans GitHub shell, se placer dans le répertoire souhaité et taper les commandes $ git add modified_file.ext $ git commit -m &quot;[descriptive message] $ git push 2.2.2 Cas où les modifications sont en conflit avec la version courante et les modifications sont mineures Il y a conflit lorsque un même fichier a été chargé par 2 collaborateurs qui ont fait des modifications et veulent valider (commit + push) leurs modifications pour renvoyer sur “GitHub.com”. Dans ce cas, le commit est possible mais pas le push. Il faut gérer le conflit : en faisant un pull (= permet de récupérer la version courante pour faire apparaitre les modifications des 2 collaborateurs) dans “GitHub Desktop” en cliquant sur Pull Origin en ouvrant le fichier en local pour sélectionner les modifications à conserver et supprimer les balises ( &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD, ======, &gt;&gt;&gt;&gt;&gt;&gt;&gt; xxxxxxxx). Le conflit étant résolu, le commit et push sont désormais possibles en cliquant sur Push Origin dans “GitHub Desktop”. 2.2.3 Cas où les modifications sont en conflit avec la version courante et les modifications sont majeures Dans le cas où les modifications des utilisateurs sont trop importantes, on peut faire le choix de créer 2 versions du fichier en créant une nouvelle branche. On obtient l’organisation suivante : Affichage de l’arborescence sous GitHub.com 2.2.3.1 Pour manipuler les branches : Sous GitHub Desktop: Pour créer une nouvelle branche, Branch -&gt; new branch , saisir un nom branch_name_to_create et cliquer sur Create branch puis sur l’icône Publish branch et faire commit to &quot;branch_name_to_create&quot; et push du fichier à mettre dans la nouvelle branche. Pour changer de branche, cliquer sur l’icône current branch et sélectionner la branche souhaitée. Pour toutes opérations sur les branches, sélectionnner la branche à manipuler et cliquer dans le menu Branch Sous GitHub Shell, se placer dans le répertoire souhaité et taper les commandes $ git branch [branch_name_to_create] $ git add modified_file.ext $ git commit -m &quot;[descriptive message] $ git push Pour changer de branche, $ git checkout [branch_name] Pour lister les branches de l’arborescence, $ git branch Pour afficher l’état du repository, $ git status (fichier modifié, ajouté, …) Pour supprimer une branche, $ git branch -d branch_name 2.3 Références Aide mémoire des commandes Git : https://services.github.com/on-demand/downloads/github-git-cheat-sheet.pdf "],
["rmarkdown.html", "Chapitre 3 RMarkdown 3.1 RMarkdown pour quoi faire ? 3.2 Comment ça marche 3.3 Un document RMarkdown à la loupe", " Chapitre 3 RMarkdown 3.1 RMarkdown pour quoi faire ? 3.1.1 Automatisation de la production de document scientifique Dans un contexte de science reproductible, produire Présentation, article, notes de cours, livre, … Code Données sous la forme de documents PDF, HTML, MS Word etc … Site web : http://rmarkdown.rstudio.com 3.2 Comment ça marche 3.2.1 Un exemple de fichier .Rmd : ce document Exemple d’un document RMarkdown 3.2.2 Schéma conceptuel Processus de production de documents 3.2.3 Markdown Un langage à balises très simple (version simplifiée de html par exemple) 3.2.3.1 Exemple ## Heading ### Sub-heading #### Another deeper heading Paragraphs are separated by a blank line. 3.2.4 Markdown Cheatsheet Tout le détail (rapide !) Détails sur Markdown 3.2.5 Pandoc C’est un convertisseur de format de documents. Il sait prendre un document d’un format x pour le passer en Markdown étendu prendre un document Markdown étendu pour le passer en un format y De fait il peut passer d’un format x à un format y https://pandoc.org/MANUAL.pdf 3.2.6 RMarkdown (Allaire et al. 2017) C’est un document pandoc avec des balises spécifiques R. http://rmarkdown.rstudio.com/lesson-1.html 3.2.7 De RMarkdown à un document finalisé avec knitr (Xie 2017c) Le bouton knit effectue les opérations suivantes : Extraire la partie Markdown texte Executer le code R pour produire les sorties demandées Intégrer les sorties précédentes dans un document html, word ou pdf 3.3 Un document RMarkdown à la loupe 3.3.1 Entete du document : YAML Un exemple d’entête de fichier RMarkdown 3.3.2 Options globales pour le code R Les options du code R du document peuvent être spécifiées par défaut 3.3.3 Code Chunk ```{r} 2+2 ``` ## [1] 4 ou python, ou sql, bash …. 3.3.4 R Code Chunk, quelques options utiles ```{r, fig.show=&#39;hide&#39;, warning=TRUE, message=FALSE} data(cars) m &lt;- mean(cars$speed) plot(speed~dist) ``` La vitesse moyenne est 15.4. References "],
["blogdown.html", "Chapitre 4 Blogdown pour créer un site 4.1 Principes de blogdown 4.2 Mise en oeuvre", " Chapitre 4 Blogdown pour créer un site Le test de blogdown n’a pas été concluant car nous avons constaté de nombreuses instabilités dès que l’on sort de l’exemple proposé (Xie 2017a). 4.1 Principes de blogdown Blogdown permet de gérer un site web à partir de pages statiques en markdown ou Rmarkdown. Le package R utilise le générateur de site Hugo. Les fichiers du site sont écrits dans le répertoire content et copiés pour devenir visible dans le répertoire public en passant par le répertoire static. 4.2 Mise en oeuvre 4.2.1 Préliminaires 4.2.1.1 Remarque MacOSX Commencer par installer homebrew https://brew.sh 4.2.1.2 Outils de base Installer une version supérieure à 1.1.350 Installer le package blogdown et Hugo install.packages(&#39;blogdown&#39;) library(&#39;blogdown&#39;) install_hugo() 4.2.2 Créer le projet par RStudio New project &gt; New Directory &gt; Website using blogdown Ne pas décocher “install hugo automatically” 4.2.3 Créer le post _index.md Le post doit être dans le répertoire principal (dégager “post”). Ce post sera la page d’accueil qui deviendra index.html dans le répertoire public 4.2.4 Visualisation du site web pour visualiser le site web, nous avons utilisé la commande Server Site du menu Addins proposé par `blogdown 4.2.5 Créer des pages additionnelles créer un post dans le répertoire principal le nom du fichier ne doit pas comporter de majuscule choisir l’extension Les hyperliens classiques markdown entre fichiers fonctionnent 4.2.5.1 Exemple Création d’un lien vers le fichier blogdown-pour-creer-un-site.Rmarkdown [Notre expérience blogdown](blogdown-pour-creer-un-site) 4.2.6 Gestion des images 4.2.6.1 Inclusion d’une images à la taille voulue les images sont stockées dans un sous répertoire du répertoire static. Dans l’exemple qui suit le répertoire des images est /static/images-markdown/ pour éviter les messages d’erreurs liés à l’édition du markdown, nous avons ajouté un champ resource-filesdans le YAML 4.2.6.2 Exemple --- title: Introduction à Rmarkdown author: &#39;&#39; date: &#39;2017-08-29&#39; resource_files: - ../static/ slug: introduction-a-rmarkdown categories: [] tags: [] --- Les images sont alors incluses comme suit: ```{r, out.width=&quot;50px&quot;, echo=TRUE, fig.show=&#39;hide&#39;} knitr::include_graphics(&quot;/images-markdown/ExempleMdFile.png&quot;, auto_pdf = TRUE, dpi = NA) ``` 4.2.7 Reste à faire publication en ligne changement de thème ou personnalisation du thème par défaut References "],
["bookdown.html", "Chapitre 5 R Bookdown 5.1 Mise en oeuvre principe 5.2 Publication du livre sur GitHub", " Chapitre 5 R Bookdown Bookdown (Xie 2017b) est un package R développé par Yihui Xe qui permet d’écrire des livres en format Rmarkdown pour les publier en pdf (via latex), epub, gitbook. Le principe de base consiste à utiliser un fichier Rmarkdown par chapitre. Une documentation assez exhaustive écrite pour l’auteur est disponible https://bookdown.org/yihui/bookdown/. Et une anti-sèche est disponible http://www.pzhao.org/en/post/bookdown-cheatsheet/. Ce chapitre vise simplement à décrire notre expérience du l’utilisation du package. 5.1 Mise en oeuvre principe 1 . Installer le package bookdown via la CRAN ou bien via devtools install.packages(&quot;devtools&quot;) devtools::install_github(&quot;rstudio/bookdown&quot;) Utiliser RStudio pour créer un répertoire “bookproject” Par défaut les fichiers RMarkdown du répertoire du “bookproject” deviendront des chapitres, ordonnés ordres alphanumériques. Il est possible d’utiliser le fichier _bookdown.yml pour changer l’ordre des chapitres. La compilation peut être effectué pour un clic sur Build Book ou par la ligne rmarkdown::render_site(output_format = &#39;bookdown::gitbook&#39;, encoding = &#39;UTF-8&#39;) Les formats de sortie possibles sont - pdf - gitbook - epub Publication (voir section 5.2 ) 5.2 Publication du livre sur GitHub Il existe de nombreuses possiblilités de publication mais nous avons testé la solution github utilisant un répertoire docs Créer un repository git pour y mettre le contenu du bookproject Nommer le répertoire de sortie docs (à la place de _book) en ajoutant dans le fichier de configuration _bookdown.yml la ligne suivante output_dir: &quot;docs&quot; Dans le répertoire “docs” ajouter un fichier vide caché nommé .nojekyll {bash, eval=FALSE, echo=TRUE} touch .nojekyll git add .nojekyll Le livre est alors accessible à l’adresse https://user.github.io/project/ dans notre cas https://cambroise.github.io/stateofther2017/ References "],
["tidyverse.html", "Chapitre 6 Découverte du tidyVerse 6.1 Motivations 6.2 Les packages du tidyverse (Wickham 2017) 6.3 Exercice", " Chapitre 6 Découverte du tidyVerse 6.1 Motivations 6.1.1 Analyse de données processus d’analyse import: récupération des données tidy: mise en forme (tableau individus variables) transform: suppression/création/filtrage de variables/individus visualization: représentation des données et validation/illustration de l’analyse model: ajustement statistique communication: diffusion des résultats (page web / présentation / article) 6.1.2 Tidy data Les données collectées ne sont (jamais) sous forme canonique pour le statisticiens. “Happy families are all alike; every unhappy family is unhappy in its own way.” –– Leo Tolstoy “Tidy datasets are all alike, but every messy dataset is messy in its own way.” –– Hadley Wickham Intérêt facilite la manipulation, la visualisation et la modélisation une structure commune, utilisée par les packages du tydiverse Philosophie de représentation des données (indépendante de R) 6.1.3 Tidy vs non tidy: exemple table2 ## # A tibble: 12 x 4 ## country year type count ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## 4 Afghanistan 2000 population 20595360 ## 5 Brazil 1999 cases 37737 ## 6 Brazil 1999 population 172006362 ## 7 Brazil 2000 cases 80488 ## 8 Brazil 2000 population 174504898 ## 9 China 1999 cases 212258 ## 10 China 1999 population 1272915272 ## 11 China 2000 cases 213766 ## 12 China 2000 population 1280428583 table1 ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 6.2 Les packages du tidyverse (Wickham 2017) tibble: structure de données readr: lecture de données tidyr (Wickham and Henry 2017): tidyfication dplyr (Wickham et al. 2017) : transformation/ “wrangling” purrr: programmation fonctionnelle / traitement successif ggplot2 (Wickham and Chang 2016) : visualisation 6.2.1 readr Import de données et création de tibble, version amélioré des data.frame (+ performant que les fonction de base) iris &lt;- read.csv(&quot;data/iris.csv&quot;) head(iris) ## sepal_length sepal_width petal_length petal_width species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa iris &lt;- readr::read_csv(&quot;data/iris.csv&quot;) iris ## # A tibble: 150 x 5 ## sepal_length sepal_width petal_length petal_width species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5.0 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## # ... with 140 more rows 6.2.2 tidyr Fonctions de mise au format tidy Évolution des fonctions classiques type reshape fonctions spread, gather, unite, separate iris_sepal &lt;- add_column(iris, ind = 1:nrow(iris)) iris_sepal &lt;- select(iris_sepal, ind, sepal_length, sepal_width, species) iris_sepal &lt;- gather(iris_sepal, key=&quot;attribute&quot;, value=&quot;measure&quot;, -species, -ind) iris_sepal &lt;- arrange(iris_sepal, ind) iris_sepal ## # A tibble: 300 x 4 ## ind species attribute measure ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 setosa sepal_length 5.1 ## 2 1 setosa sepal_width 3.5 ## 3 2 setosa sepal_length 4.9 ## 4 2 setosa sepal_width 3.0 ## 5 3 setosa sepal_length 4.7 ## 6 3 setosa sepal_width 3.2 ## 7 4 setosa sepal_length 4.6 ## 8 4 setosa sepal_width 3.1 ## 9 5 setosa sepal_length 5.0 ## 10 5 setosa sepal_width 3.6 ## # ... with 290 more rows 6.2.3 dplyr Fonctions de transformation et manipulation de données select: sélection variables filter : sélection d’observations arrange : réordonner les observations mutate : créer de nouvelles variables à partir d’existante summarize: résumé de plusieurs variables et aussi rename, group_by by_species &lt;- group_by(iris, species) dplyr::summarize(by_species, moyenne = mean(sepal_length)) ## # A tibble: 3 x 2 ## species moyenne ## &lt;chr&gt; &lt;dbl&gt; ## 1 setosa 5.006 ## 2 versicolor 5.936 ## 3 virginica 6.588 6.2.4 purrr Définition de l’opérateur pipe %&gt;% pour “enchaîner” les traitement sur un tibble Force à la programmation fonctionnelle (une fonction = un argument, une sortie) iris_sepal &lt;- iris %&gt;% add_column(ind = 1:nrow(iris)) %&gt;% select(ind, sepal_length, sepal_width, species) %&gt;% gather(key=&quot;attribute&quot;, value=&quot;measure&quot;, -species, -ind) %&gt;% arrange(ind) iris_sepal ## # A tibble: 300 x 4 ## ind species attribute measure ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 setosa sepal_length 5.1 ## 2 1 setosa sepal_width 3.5 ## 3 2 setosa sepal_length 4.9 ## 4 2 setosa sepal_width 3.0 ## 5 3 setosa sepal_length 4.7 ## 6 3 setosa sepal_width 3.2 ## 7 4 setosa sepal_length 4.6 ## 8 4 setosa sepal_width 3.1 ## 9 5 setosa sepal_length 5.0 ## 10 5 setosa sepal_width 3.6 ## # ... with 290 more rows 6.2.5 ggplot2 Outil de visualisation ggplot(iris, mapping = aes(x= species, y=sepal_length)) + geom_boxplot() ggplot(iris, mapping = aes(x= species, y=sepal_length, color = species)) + geom_jitter() ggplot(iris, mapping = aes(x= species, y=sepal_length, colour=species)) + geom_boxplot() + geom_jitter(alpha=0.5) + labs(title=&quot;un très beau graphe&quot;, x=&quot;espèce&quot;, y=&quot;longueur de sépale&quot;) ggplot(iris, mapping = aes(x= species, fill=species)) + geom_bar() + coord_polar() + theme_bw() by_attr &lt;- gather(iris, key = &quot;attribut&quot;, value=&quot;measurement&quot;, sepal_length,sepal_width, petal_length,petal_width) head(attr) ## ## 1 .Primitive(&quot;attr&quot;) ggplot(by_attr, mapping = aes(x=attribut, y=measurement, fill=species)) + geom_boxplot() ``` ggplot(by_attr, mapping = aes(x=attribut, y=measurement)) + geom_boxplot() + facet_grid(~species) ggplot(by_species, mapping = aes(x=sepal_width, y=sepal_length, group=species, colour=species)) + geom_smooth(method=lm) + geom_point() ggplot(by_species, mapping = aes(x=sepal_width, y=sepal_length, group=species, colour=species)) + geom_smooth(method=loess) + geom_point() 6.3 Exercice Lisez les données suivantes à l’adresse http://stat405.had.co.nz/data/pew.txt Transformez en une tibble à trois colonnes religion income effectif Pour les durs: calculez le salaire moyen par religion (après conversion en numerique du salaire) Pour vous aider : http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf 6.3.1 Solution pew &lt;- readr::read_delim(file=&quot;http://stat405.had.co.nz/data/pew.txt&quot;, delim=&quot;\\t&quot;) ## Parsed with column specification: ## cols( ## religion = col_character(), ## `&lt;$10k` = col_integer(), ## `$10-20k` = col_integer(), ## `$20-30k` = col_integer(), ## `$30-40k` = col_integer(), ## `$40-50k` = col_integer(), ## `$50-75k` = col_integer(), ## `$75-100k` = col_integer(), ## `$100-150k` = col_integer(), ## `&gt;150k` = col_integer(), ## `Don&#39;t know/refused` = col_integer() ## ) pew &lt;- read_tsv(file=&quot;http://stat405.had.co.nz/data/pew.txt&quot;) ## Parsed with column specification: ## cols( ## religion = col_character(), ## `&lt;$10k` = col_integer(), ## `$10-20k` = col_integer(), ## `$20-30k` = col_integer(), ## `$30-40k` = col_integer(), ## `$40-50k` = col_integer(), ## `$50-75k` = col_integer(), ## `$75-100k` = col_integer(), ## `$100-150k` = col_integer(), ## `&gt;150k` = col_integer(), ## `Don&#39;t know/refused` = col_integer() ## ) tidy_pew &lt;- pew %&gt;% gather(key=&quot;income&quot;, value=&quot;effectif&quot;, -religion) convert &lt;- function(income) { convert.one &lt;- function(x) { switch(x, &quot;&lt;$10k&quot; = 5000, &quot;$10-20k&quot; = 15000, &quot;$20-30k&quot; = 25000, &quot;$30-40k&quot; = 35000, &quot;$40-50k&quot; = 45000, &quot;$50-75k&quot; = 62500, &quot;$75-100k&quot;= 87250, &quot;$100-150k&quot; = 125000, &quot;&gt;150k&quot; = 200000, NA ) } sapply(income, convert.one) } tidy_pew %&gt;% mutate(income.numeric = convert(income)) %&gt;% group_by(religion) %&gt;% summarise(mean.income = weighted.mean(income.numeric, effectif, na.rm=TRUE)) %&gt;% arrange(desc(mean.income)) ## # A tibble: 18 x 2 ## religion mean.income ## &lt;chr&gt; &lt;dbl&gt; ## 1 Hindu 109776.14 ## 2 Jewish 108197.60 ## 3 Atheist 85886.67 ## 4 Orthodox 83303.45 ## 5 Buddhist 79508.40 ## 6 Agnostic 79495.89 ## 7 Mainline Prot 73038.95 ## 8 Other Christian 72617.12 ## 9 Don’t know/refused 72049.68 ## 10 Other Faiths 70267.20 ## 11 Catholic 70061.73 ## 12 Other World Religions 69389.71 ## 13 Mormon 68732.91 ## 14 Muslim 65409.57 ## 15 Unaffiliated 65361.98 ## 16 Evangelical Prot 58589.36 ## 17 Jehovah&#39;s Witness 48588.48 ## 18 Historically Black Prot 47697.61 References "],
["R6.html", "Chapitre 7 Programmation orientée object à l’aide de classe R6 7.1 Principes et buts 7.2 Exemple de classes pour le modèle linéaire (généralisé) 7.3 Exercice 7.4 Quelques remarques supplémentaires", " Chapitre 7 Programmation orientée object à l’aide de classe R6 7.1 Principes et buts Un objet est une sorte de liste mieux structurée. Principe : créer de nouvelles classes avec des attributs/champs (variables) définis et des méthodes (fonctions propres) un objet est alors instancié à partir d’une classe, créer des classes générales et des classes plus spécifiques qui héritent des clases générales. Intérêt : structurer le code, éviter de dupliquer le code, plus facile à débugger, plus robuste, plus lisible pour la diffusion, coder à plusieurs. Structure d’une classe R6 (Chang 2017) library(R6) maclasse=R6class(&quot;maclasse&quot;, public=list( attr1=NULL, attr2=NULL, attr3=NULL, initialize=function(attr1=NA,attr2=NA) { self$attr1=attr1 self$attr2=attr2 private$check() private$attr4=attr1+attr2 }, somme=function() { return(private$attr4) } ), private=list( attr4=NULL, check=function() { if (self$attr1&lt;0) stop(&quot;attr1 must be positive&quot;) } ) ) self$... permet d’appeler (dans la définition de la classe) les champs et les méthodes propres à la classe déclarés en public. private$ permet d’appeler (dans la définition de la classe) les champs et les méthodes propres à la classe déclarés en private. on crée/instancie un objet de la classe en tapant obj=maclasse$new(a1,a2). on appelle les méthodes de la classe en tapant maclasse$somme(). on peut créer des sous-classes qui hériteront d’une classe supérieure. 7.2 Exemple de classes pour le modèle linéaire (généralisé) On commence par créer des classes modèles ajustées qui contiennent les paramètres qui seront ajustés par le modèle. library(R6) modlin_ajuste=R6Class(&quot;modlin_ajuste&quot;, public = list( X=NULL, beta=NULL, initialize=function(X,beta) { self$X=X self$beta=beta } ) ) On a créé une classe générale et on crée 2 sousclasses qui en hériteront : gauss_modlin_ajuste et poiss_modlin_ajuste. Dans la définition des sous-clases, la commande inherit permet de faire hériter de la classe précédemment définie. Pour le modèle gaussien, on peut compléter l’initialisation pour ajouter \\(\\sigma^2\\) en utilisant super$initialize(X,beta) dans la fonction intialize de cette classe. poiss_modlin_ajuste=R6Class(&quot;poiss_modlin_ajuste&quot;, inherit = modlin_ajuste, public = list( pred=function(Xnew=NULL) { if (is.null(Xnew)) { return(exp(self$X%*%self$beta)) } else return(exp(Xnew%*%self$beta)) }, sim=function(Xnew=NULL) { if (is.null(Xnew)) { return(rpois(nrow(self$X),self$pred())) } else return(rpois(nrow(Xnew),self$pred(Xnew))) } ) ) gauss_modlin_ajuste=R6Class(&quot;gauss_modlin_ajuste&quot;, inherit = modlin_ajuste, public = list( sigma2=NULL, initialize=function(X,beta,sig2) { super$initialize(X,beta) self$sigma2=sig2 private$check() }, pred=function(Xnew=NULL) { if (is.null(Xnew)) { return(self$X%*%self$beta) } else return(Xnew%*%self$beta) }, sim=function(Xnew=NULL) { if (is.null(Xnew)) { return(rnorm(nrow(self$X),self$pred(),sqrt(self$sigma2))) } else return(rnorm(nrow(Xnew),self$pred(Xnew),sqrt(self$sigma2))) } ), private = list( check=function() { if (self$sigma2&lt;0) stop(&quot;sigma^2 must be positive&quot;) } ) ) On essaie : modgauss=gauss_modlin_ajuste$new(matrix(runif(100,1,7),50,2),c(-2,6),3) # on accede aux champs ainsi modgauss$beta ## [1] -2 6 # on peut utiliser les fonctions pour simuler aux points du meme design modgauss$sim() ## [1] 30.3026913 2.0148851 2.5378878 30.8062072 11.0003090 9.4520259 ## [7] 21.7530745 10.8025728 4.1032779 -2.3256148 29.2925623 26.3472471 ## [13] 8.8482835 20.3883006 18.9995275 1.3751197 0.5571728 27.2538781 ## [19] 26.7506579 28.6958597 30.3015413 15.7143468 10.4480319 35.6815958 ## [25] 17.1338287 -0.1472169 2.8910210 25.3851587 11.0187985 -6.4996732 ## [31] 4.3187872 20.4985549 0.6524501 5.5471982 10.8619230 14.9489712 ## [37] 1.8027747 9.5087357 5.2726845 3.6816722 20.7195812 10.1851391 ## [43] 38.3629592 5.5777728 3.7932440 -6.0644844 8.3738535 3.7933400 ## [49] 15.5857183 27.1590429 # on peut utiliser la meme fonction pour simuler aux points d&#39;un autre design modgauss$sim(matrix(c(0,2),1,2)) ## [1] 9.632181 On crée à présent les classes permettant de recevoir les données. Une fonction estime au sein de ces classes aura pour sortie un modèle ajusté. don=R6Class(&quot;don&quot;, public=list( Y=NULL, X=NULL, initialize=function(X,Y) { self$X=X self$Y=Y private$check() } ), private=list( check=function() { if (nrow(self$X)!=length(self$Y)) stop(&quot;êtes vous ivre ?&quot;) } ) ) On distingue une classe pour le modèle Poisson et pour le modèle gaussien. poisdon=R6Class(&quot;poisdon&quot;, inherit = don, public = list( estime=function() { res=glm(self$Y~self$X-1,family = &quot;poisson&quot;) obj=poiss_modlin_ajuste$new(self$X,unname(res$coefficients)) return(obj) } ) ) On essaie #on définit un modèle modpois=poiss_modlin_ajuste$new(matrix(runif(100,-1,2),50,2),c(1,2)) #on simule selon ce modele Y=modpois$sim() X=modpois$X # on cree la structure donnees ex=poisdon$new(X,Y) #on estime est=ex$estime() est$beta ## [1] 0.9607296 2.0176417 #on peut prédire selon le modèle est$pred(matrix(c(1,2),1,2)) ## [,1] ## [1,] 147.8226 On fait de même pour les données censées suivre une loi gaussienne en ajoutant la fonction à la suite de la définition de la classe. Ceci est utile lorsque les fonctions sont trop volumineuses. gaussdon=R6Class(&quot;gaussdon&quot;, inherit = don) gaussdon$set(&quot;public&quot;,&quot;estime&quot;, function() { beta &lt;- solve(t(self$X)%*% self$X) %*% t(self$X) %*% self$Y sigma2 &lt;- sum((self$Y - self$X %*% beta)^2)/(nrow(self$X) - ncol(self$X)) obj=gauss_modlin_ajuste$new(self$X,c(beta),sigma2) return(obj) } ) modgauss=gauss_modlin_ajuste$new(matrix(runif(100,1,7),50,2),c(-2,6),3) X=modgauss$X Y=modgauss$sim() exx=gaussdon$new(X,Y) estt=exx$estime() estt$beta ## [1] -2.042663 5.950375 estt$sigma2 ## [1] 2.176496 Si on s’était trompé sur les dimensions. modgauss=gauss_modlin_ajuste$new(matrix(runif(100,1,7),50,2),c(-2,6),3) X=modgauss$X Y=modgauss$sim() Y=Y[-1] a=try(gaussdon$new(X,Y)) print(a) ## [1] &quot;Error in private$check() : êtes vous ivre ?\\n&quot; ## attr(,&quot;class&quot;) ## [1] &quot;try-error&quot; ## attr(,&quot;condition&quot;) ## &lt;simpleError in private$check(): êtes vous ivre ?&gt; 7.3 Exercice Coder la sous-classe correspondante au modèle linéaire généralisée pour une loi bernoulli (lien logit ou probit) Coder en classe votre modèle préféré 7.4 Quelques remarques supplémentaires Pour diffuser un code, certains (dont JC) pensent qu’il vaut mieux refaire une surcouche qui s’appelle de manière classique avec une fonction et des options. Exemple fitmod=function(X,Y,loi) { switch(loi, poisson={ obj=poisdon$new(X,Y) res=obj$estime() return(res$beta) }, gaussien={ obj=gaussdon$new(X,Y) res=obj$estime() return(list(res$beta,res$sigma2)) } ) } Lorsque l’on veut copier un objet (par exemple exx de la classe gaussdon), il faut faire : a=exx$clone() Sinon, si on fait b=exx, on modifiera exx en modifiant b. Quelques liens utiles : vignette sur les classes R6 Think R partie 1 Think R partie 2 References "],
["packages.html", "Chapitre 8 Création de package avec Rstudio 8.1 Introduction 8.2 Création d’un package rudimentaire 8.3 Intégration de code C++", " Chapitre 8 Création de package avec Rstudio 8.1 Introduction L’objectif de ce petit tutoriel est de créer un projeet package sous Rstudio (avec le package devtools (Wickham and Chang 2017)), de se familiariser avec les outils de documentation, d’intégrer un code C++, de déposer un package sur github. 8.2 Création d’un package rudimentaire Supposons qu’on dispose de la fonction OLS &lt;- function(X,y) { beta.hat &lt;- chol2inv(chol(crossprod(X))) %*% crossprod(X,y) beta.hat } 8.2.1 Exercice 1 Créer un projet package via Rstudio: File -&gt; New Project -&gt; New Directory -&gt; New Package with git repository Vous pouvez également utiliser directement la commande devtools::create(&quot;OLSfit&quot;) 8.2.2 Exercice 2 Effacer le fichier hello.R. Créer un fichier OLS.R contenant votre fonction. 8.2.3 Exercice 3 Éditer le fichier DESCRIPTION de manière adéquate: modifier le titre, le nom de l’auteur, du mainteneur, la description. Pour le nom de l’auteur, utiliser person(&quot;First&quot;, &quot;Last&quot;, email = &quot;first.last@example.com&quot;, role = c(&quot;aut&quot;, &quot;cre&quot;)) 8.2.4 Exercice 4 Documentez la fonction OLS à l’aide de Roxygen2 (Wickham, Danenberg, and Eugster 2017) : pour ce faire, complétez le code suivant et collez-le dans l’entête de votre fichier OLS.R. La balise @export indique que cette fonction doit être rendue public à l’utilisateur. Lors de la compilation de la documentation, le fichier NAMESPACE sera amendé en ce sens. Question #&#39; Description of the function #&#39; #&#39; @param a paramter #&#39; @return what is returned #&#39; @examples #&#39; @export OLS &lt;- function(X,y) { beta.hat &lt;- chol2inv(chol(crossprod(X))) %*% crossprod(X,y) beta.hat } Solution #&#39; Compute the OLS esstimator #&#39; #&#39; @param X A matrix #&#39; @param y A vector #&#39; @return a vector of coefficients #&#39; @examples #&#39; n &lt;- 100; p &lt;- 10 #&#39; X &lt;- matrix(rnorm(n*p), n, p) #&#39; beta &lt;- runif(p, 1, 2) * sample(c(-1,1), p, rep=TRUE) #&#39; y &lt;- X %*% beta + rnorm(n) #&#39; OLS(X,y) #&#39; @export OLS &lt;- function(X,y) { beta.hat &lt;- chol2inv(chol(crossprod(X))) %*% crossprod(X,y) beta.hat } Effacez le fichier NAMESPACE et lancez la commande devtools::document() pour générer les fichiers d’aide et mettre à jour le NAMESPACE. 8.2.5 Exercice 5 Contruire le package et l’installer. Lorsqu’on dispose d’un projet Rstudio associé à un package, ceci peut être fait simplement à l’aide du raccourci Ctrl + Shift + B ou du bouton correspondant en haut à droite. Vérifier que le package et le code fonctionnent via l’exemple de votre fonction. Vérifier que votre package est publibale sur CRAN à l’aide du bouton Check ou du raccourci Ctrl + Shift + E. 8.3 Intégration de code C++ On souhaite accélérer le code en réalisant la partie coûteuse des calculs à l’aide d’un code C++. 8.3.1 Exercice 1 Spécifiez via Rstudio que vous allez dorénavant utiliser du code C++, à l’aide de la commande devtools::use_rcpp() Observez les modifications apportées à votre packages. Commentez. 8.3.2 Exercice 2 Créer un fichier OLS-pkg.R dans lequel vous intégrerez les lignes suivantes. Vous pouvez également compléter ce fichier pour écrire un texte de présentation générale de votre package qui apparaîtra en début de documentation. #&#39; package OLSfit #&#39; #&#39; Dans ce package, on trouve les fonctions trucs bidule et muche. Elles font ceci et cela. Les classes d&#39;objets Robert et MItchoum font etc. #&#39; #&#39; @name OLS-pkg #&#39; @docType package #&#39; #&#39; @useDynLib OLSfit #&#39; @importFrom Rcpp sourceCpp NULL 8.3.3 Exercice 3 Créez un fichier OLS.cpp dans le répertoire src. À l’aide d’armadillo, compléter le fichier suivant: Question #include &quot;RcppArmadillo.h&quot; // [[Rcpp::depends(RcppArmadillo)]] NumericVector OLScpp(const arma::mat X, const arma::vec y) { } Solution #include &quot;RcppArmadillo.h&quot; // [[Rcpp::depends(RcppArmadillo)]] NumericVector OLScpp(const arma::mat X, const arma::vec y) { return wrap( inv_sympd(X.t() * X) * X.t() * y ) ; } Ajoutez RcppArmadillo au champ LinkingTo du fichier DESCRIPTION. Enfin, faites un build and reload de votre package. Constatez les fichiers nouvellement créer. Commentez. 8.3.4 Exercice 4 Ouvrez le ficher RcppExport.R. À l’aide de son contenu, créer une nouvelle fonction OLSfast dans un nouveau fichier. Regénérer les fichiers de doc à l’aide de Roxygen2. Comparer OLS à OLSfast avec microbenchmark. 8.3.5 Exercice 5 Publiez votre package sur github. References "],
["references-1.html", "References", " References "]
]
